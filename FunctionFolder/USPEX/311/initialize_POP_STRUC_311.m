function initialize_POP_STRUC_311()

% USPEX Version 9.3.0
% Change: variable composition added
global ORG_STRUC
global POP_STRUC
global POOL_STRUC

POOL_STRUC = struct('POPULATION',{}, 'Composition_ratio',{}, 'Composition_ranking',{}, ...
                     'Composition_surviving',{}, 'Composition_Bestenthalpy',{}, 'Composition_fitness',{});
POOL_STRUC(1).POPULATION  = struct('COORDINATES', {}, 'LATTICE', {}, 'numIons', {}, 'numMols', {}, ...
                            'MOLECULES', {}, 'numBlocks',{}, 'order', {}, 'enthalpy', {}, 'Number', {});
POOL_STRUC.POPULATION(1) = QuickStart(POOL_STRUC.POPULATION);
for i=1:size(ORG_STRUC.numIons,1)
    POOL_STRUC.Composition_ratio(i,:) = ORG_STRUC.numIons(i,:)/sum(ORG_STRUC.numIons(i,:));
    POOL_STRUC.Composition_ranking(i) = 0;
    POOL_STRUC.Composition_surviving(i) = 1;
    POOL_STRUC.Composition_Bestenthalpy(i) = 1000;
    POOL_STRUC.Composition_fitness(i) = 1000;
end

POP_STRUC = struct('POPULATION',{}, 'SOFTMODEParents',{}, 'SOFTMUTATED',{}, 'resFolder', {},'generation',{}, ...
'DoneOrder',{}, 'bodyCount', {}, 'ranking',{},'bad_rank',{}, 'convex_hull',{}, 'fitness', {});
POP_STRUC(1).POPULATION = struct('COORDINATES',{},'INIT_COORD',{},'LATTICE',{},'INIT_LAT',{},'INIT_numIons',{},'MOLECULES',{},'order',{},...
'struc_entr',{},'S_order',{},'FINGERPRINT',{},'K_POINTS',{},'Step', {},'Enthalpies', {},'Error',{},'Done',{},'ToDo',{},'Parents',{},...
'howCome',{},'JobID',{},'Folder',{},'numIons', {}, 'numBlocks', {}, 'numMols', {}, 'MtypeLIST',{}, 'typesAList',{},'Number',{},'symg', {});
POP_STRUC.POPULATION(1) = QuickStart(POP_STRUC.POPULATION);

POP_STRUC(1).POPULATION(1).MOLECULES=struct('MOLCOORS',{},'ZMATRIX',{},'ID',{},'MOLCENTER',{},'order',{});
POP_STRUC(1).SOFTMUTATED = struct('FINGERPRINT',{}, 'mutatedAt', {}, 'fallBack', {});
POP_STRUC(1).SOFTMODEParents=struct('lattice',{},'coordinates',{},'molecules',{},'fingerprint',{},'molfingerprint',{},'eignFre',{},'eignVec',{},'Softmode_Fre',{},'Softmode_num',{},'numIons',{},'numBlocks',{});

POP_STRUC.generation = 1;
POP_STRUC.bodyCount = 0;
POP_STRUC.bad_rank = 0;

N_T = size(ORG_STRUC.numMols,1);
IPS = ORG_STRUC.initialPopSize;

%   if exist('Seeds/compositions')
%        disp('------ Using the compositions given by user! -------')
%        disp(' ');
%        tmpfirstGeneSplit=load('Seeds/compositions');
%        tmpsplitN=length(tmpfirstGeneSplit);
%
%        firstGeneSplit=[0,0];
%        splitN=0;
%        for i = 1:tmpsplitN
%            if ( sum(tmpfirstGeneSplit(i,:))>ORG_STRUC.maxAt ) |  ( sum(tmpfirstGeneSplit(i,:))<ORG_STRUC.minAt )
%               disp(['The composition : ' num2str(tmpfirstGeneSplit(i,:)) ' will be discarded !' ]);
%            else
%               splitN=splitN+1;
%               firstGeneSplit(splitN,1:2)=tmpfirstGeneSplit(i,:); 
%            end
%        end
%        ORG_STRUC.firstGeneSplit=firstGeneSplit;
%        ORG_STRUC.splitN = splitN;
%   else
   	fp = fopen('Seeds/compositions', 'w');
   	for i=1:size(ORG_STRUC.firstGeneSplit,1)
      	      for j=1:size(ORG_STRUC.firstGeneSplit,2)
      	            fprintf(fp, '%4d', ORG_STRUC.firstGeneSplit(i,j));
              end
      	      fprintf(fp, '\n');
   	end
   	fclose(fp);
%   end

   if (ORG_STRUC.firstGeneMax == 0) | (ORG_STRUC.firstGeneMax > IPS)
      ORG_STRUC.firstGeneMax = IPS;
   end
   if (ORG_STRUC.firstGeneMax > ORG_STRUC.splitN)
      ORG_STRUC.firstGeneMax = ORG_STRUC.splitN;
   end
   split_rank_temp = randperm(ORG_STRUC.splitN);
   split_rank = split_rank_temp;

% we want only different compositions, including all single block compositions
% single elements:
   for it = 1 : N_T
    for jt = 1 : ORG_STRUC.splitN
     if sum(ORG_STRUC.firstGeneSplit(split_rank_temp(jt),:)) == ORG_STRUC.firstGeneSplit(split_rank_temp(jt),it)
       split_rank(it) = split_rank_temp(jt);
       split_rank(jt) = split_rank_temp(it);
       split_rank_temp = split_rank;
       break;
     end
    end
   end
% identical compositions are moved away till we reach firstGeneMax different ones
   cnt = N_T;
   split_rank_temp = split_rank;
   for it = 1 : ORG_STRUC.splitN
    good_comp = 1; 
    for jt = 1 : cnt
     same = sameComposition(ORG_STRUC.firstGeneSplit(split_rank(jt),:), ORG_STRUC.firstGeneSplit(split_rank_temp(it),:));
     if same == 1
       good_comp = 0;
     end
    end
    if (good_comp == 1) && (size(ORG_STRUC.firstGeneSplit,1) - it) <= (ORG_STRUC.firstGeneMax - cnt)
      good_comp = 1;
    end
    if good_comp == 1
     cnt = cnt + 1;
     split_rank(cnt) = split_rank_temp(it);
     split_rank(it) = split_rank_temp(cnt);
    end
    if cnt >= ORG_STRUC.firstGeneMax
      break;
    end
   end 
% at this stage we have firstGeneMax different compositions at the beginning of the population and then whatever was generated by randperm

if ORG_STRUC.firstGeneMax < N_T    % if we found almost no compositions due to strict min/maxAt - at least do all single block ones
  ORG_STRUC.firstGeneMax = N_T;
end   

% vary the number of formula units in the unit cell for same position on the convex hull
% change the algorithm as soon as the number of possible compositions is big enough to slow it down
   spl = 1;
   for it = 1 : IPS
     while spl > ORG_STRUC.firstGeneMax
       spl = spl - ORG_STRUC.firstGeneMax;
     end
     POP_STRUC.POPULATION(it).numBlocks = ORG_STRUC.firstGeneSplit(split_rank(spl),:);
% exclude the case of two identical blocks
% add an element of randomness; numIons for single element compositions can be anything between maxAt and minAt now:
     if N_T > 1      
      if spl <= N_T 
       POP_STRUC.POPULATION(it).numBlocks = zeros(1, N_T); %make sure single block is always single block
       POP_STRUC.POPULATION(it).numBlocks(spl) = round(ORG_STRUC.minAt/sum(ORG_STRUC.numIons(spl,:))) + round(rand*((ORG_STRUC.maxAt-ORG_STRUC.minAt)/sum(ORG_STRUC.numIons(spl,:))));
       while sum(POP_STRUC.POPULATION(it).numBlocks(spl)*ORG_STRUC.numIons(spl,1:end)) > ORG_STRUC.maxAt
          POP_STRUC.POPULATION(it).numBlocks(spl) = POP_STRUC.POPULATION(it).numBlocks(spl) - 1;
          if POP_STRUC.POPULATION(it).numBlocks(spl) < 0
            break;
          end
       end
       if POP_STRUC.POPULATION(it).numBlocks(spl) < 1
         POP_STRUC.POPULATION(it).numBlocks(spl) = 1;
       end
      else % add an element of randomness if possible
       tmp = POP_STRUC.POPULATION(it).numBlocks;
       for i = 1 : ORG_STRUC.splitN
        same = sameComposition(POP_STRUC.POPULATION(it).numBlocks, ORG_STRUC.firstGeneSplit(i,:));
        if same == 1
          tmp = vertcat(tmp,ORG_STRUC.firstGeneSplit(i,:));
        end
       end
       k = 1 + floor(rand*size(tmp,1));
       POP_STRUC.POPULATION(it).numBlocks = tmp(k,:);
      end
     end
     spl = spl + 1;
   end

   for it = 1 : IPS
     POP_STRUC.POPULATION(it).numMols = POP_STRUC.POPULATION(it).numBlocks*ORG_STRUC.numIons;
   end


%create good initial population. Every individual fulfills hard constraints.
    goodPop = 1;
    newSym = 1;
    badSymmetry = 0;
    nsym = 0;
while goodPop < ORG_STRUC.initialPopSize+0.5

%Here we check the position of molecule center is reasonable or not
    errorS = 0;
    Stokes = 0;
    badSymmetry = 0;
    newSym = 1;  

    CenterminDist = ORG_STRUC.CenterminDistMatrice;
    running = 1;
    while running
          numMols = POP_STRUC.POPULATION(goodPop).numMols;
          numBlocks = POP_STRUC.POPULATION(goodPop).numBlocks;
      if ORG_STRUC.nsymN(1,1) == 0  % H. Stokes code to create a crystal with given symmetry
         if badSymmetry > 5
               badSymmetry = 0;
               newSym = 1;      % change the symmetry group if can't generate the crystal
         end
         badSymmetry = badSymmetry + 1;
         if newSym
           tmp = find(ORG_STRUC.nsym > 0);
           nsym = tmp(ceil(rand*length(tmp))); % pick a random group from those specified by user
           newSym = 0;
         end

         lat1 = 0;
         for it = 1 : length(ORG_STRUC.latVolume)
           lat1 = lat1 + numBlocks(it)*ORG_STRUC.latVolume(it);
         end

         if (nsym > 1)  % if nsym == 1 - just keep the random candidate that we generated
            cd(['CalcFoldTemp'])
            [candidate, lat, numSites, Operation, errorS, errorN, P, PB] = symope_311(nsym, numMols, lat1, CenterminDist);
            cd(ORG_STRUC.homePath)
            if errorS == 0
               POP_STRUC.POPULATION(goodPop).LATTICE = lat;
               running = 0;
			   if distanceCheck(candidate, lat, numMols, CenterminDist-0.2)
                  goodbad = 1;
               else
                  % disp('Perhaps a bug of symmetry Code');
                  % candidate
                  goodbad = 0;
               end
            end
         end
     end
   end
        
  if goodbad
     [typesAList, MtypeLIST, numIons] = GetPOP_MOL(numMols);
     for item=1:20
        Molecules = struct('MOLCOORS',{},'ZMATRIX',{},'ID',{},'MOLCENTER',{});
        Molecules = [];
        Molecules = GetOrientation(candidate, lat, numSites(:,1), Operation, MtypeLIST, nsym, P, PB);
        for innerInder= 1: sum(numMols)
           Molecules(innerInder).ZMATRIX = real(NEW_coord2Zmatrix(Molecules(innerInder).MOLCOORS,ORG_STRUC.STDMOL(MtypeLIST(innerInder)).format));
        end
        goodBad = newMolCheck(Molecules,lat, MtypeLIST, ORG_STRUC.minDistMatrice);
        if goodBad
          [typesAList, MtypeLIST, numIons] = GetPOP_MOL(numMols);
           POP_STRUC.POPULATION(goodPop).MOLECULES=Molecules;
           POP_STRUC.POPULATION(goodPop).numMols=numMols;
           POP_STRUC.POPULATION(goodPop).MtypeLIST = MtypeLIST;
           POP_STRUC.POPULATION(goodPop).typesAList = typesAList;
           POP_STRUC.POPULATION(goodPop).numIons=numIons;
           POP_STRUC.POPULATION(goodPop).LATTICE = lat;
           POP_STRUC.POPULATION(goodPop).howCome = '  Random  ';

           disp(['Molecular Crystal '  num2str(goodPop) ' built with the symmetry group ' num2str(nsym) ' (' spaceGroups(nsym)  '), composition '  num2str(numMols) ' ']);
           disp(['Compositions: ' num2str(numMols) '  Volume: ' num2str(det(lat))]);
           disp(' ');
           goodPop = goodPop+1;
          break
        end
      end
   end
end

pick_Seeds();
Start_POP_311();

